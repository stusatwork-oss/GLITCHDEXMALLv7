# CUTSCENE ENGINE - Sora-Powered FMV Omen System ðŸŽ¬ðŸ‘ï¸

**The mall doesn't just simulate. It REMEMBERS.**

When rare, specific conditions occur in the simulation, the Cutscene Engine triggers Full Motion Video sequences generated by Sora. These aren't random trailers - they're omens, memories, and narrative beats tied directly to gameplay events.

---

## What Sora Is in Mall_OS Now

**Not:** "Make me a random mall trailer"

**Is:** A cutscene engine for:
- Rule breaks (Janitor enters forbidden zone)
- Cloud spikes (Threshold crossed at 85)
- Toddler manifestations (Becomes fully visible)
- HOLOmister freak-outs (First glitch)
- Cray altar events (Future integration)

**Mental Pattern (Put This on a Post-it):**

```
Sim detects rare state â†’ Event fires â†’ Cutscene table checks â†’ If allowed, Sora clip plays â†’ Sim resumes
```

---

## Data Layout

Cutscenes live in `data/cutscenes/*.json`. Each file is self contained:
- `id`, `display_name`, `type`, `duration_seconds`
- `trigger`: event name plus optional zone/threshold/conditions list
- `sora_prompt_id` and inline `sora_prompt` (description + style + camera)
- `replay_policy`: `once_per_save`, `once_per_run`, or `once_per_profile`
- `blocking`: whether the sim pauses while the clip plays
- `post_actions`: declarative hints for scripting after playback

Examples added:
- `janitor_fc_arcade_first_time.json` â†’ `JANITOR_RULE_BROKEN@FC-ARCADE`
- `cloud_crosses_85.json` â†’ `CLOUD_THRESHOLD_CROSSED@85 (rising)`
- `toddler_manifests.json` â†’ `TODDLER_MANIFESTING` in `SERVICE_CORRIDOR`
- `holomister_glitch.json` â†’ `HOLOMISTER_GLITCH` when the first major glitch happens

---

## Runtime Engine

`src/cutscenes/cutscene_engine.py` provides a minimal runtime that can be called by the sim loop or event bus.

```python
from cutscenes import CutsceneEngine, SimulationEvent, handle_event

engine = CutsceneEngine(cutscene_dir="data/cutscenes")
engine.load_all()

# When something strange happens:
event = SimulationEvent(
    name="HOLOMISTER_GLITCH",
    zone="ATRIUM",
    cloud=92,
    metadata={"toddler_distance": 10, "glitched": True},
)
handle_event(event, sim_state, engine, current_time)
```

**Key parts:**
- `CutsceneEngine.load_all()` reads all JSON definitions
- `SimulationEvent.matches(cutscene)` checks event name, zone, thresholds, and boolean/metric conditions
- `ReplayPolicy` enforces `once_per_*` limits using an in-memory tracker keyed by save/profile
- `handle_event` routes events to the engine, records when a cutscene was last seen, and returns structured playback info

---

## Best Practices

- Keep `trigger.conditions` human-readable (e.g., `"cloud.level >= 85"`) for debug UIs.
- Use `post_actions` to hint at follow-up scripting (apply moods, mark NPC memory, adjust Cloud) rather than doing it in-engine.
- Prefer `blocking=true` for omen moments; non-blocking scenes should be short or purely cosmetic.
- Store SFX/camera/style hints in `sora_prompt` so prompt engineers have everything in one place.

---

## Extending

- Add new cutscenes by dropping more JSON files into `data/cutscenes`.
- Implement persistence of `seen_cutscenes` in your save system by reading/writing `engine.seen_cutscenes`.
- Emit analytics hooks when `handle_event` returns a cutscene so narrative telemetry captures when omens occur.
- For future Cray altar events, reuse the same schema with custom conditions (`"altar.awake == True"`).
